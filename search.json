[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EuroFab research project",
    "section": "",
    "text": "The landing page of the EuroFab project."
  },
  {
    "objectID": "notebooks/hilbert_split.html",
    "href": "notebooks/hilbert_split.html",
    "title": "Hilbert distance-based split into train and test",
    "section": "",
    "text": "This notebook illustrates the core of the approach to split chips into train and test used in the CEUS paper. There it was a bit more complicated than that but the principle is illustrated here.\n\nimport geopandas as gpd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely import box\n\nGet only a subset of the country for illustration - NW.\n\nstart_x, start_y, end_x, end_y = (321566, 365379, 468106, 437198)\n\nLoad the data and clip them to the box defined above. The data from https://figshare.com/ndownloader/files/38736501\n\nsignatures  = gpd.read_file(\"/Users/martin/Downloads/spatial_signatures_GB_simplified.gpkg\", bbox=(start_x, start_y, end_x, end_y)).clip(box(start_x, start_y, end_x, end_y))\n\nGet coordinates of chip centroids.\n\nx_coords = np.arange(start_x, end_x, 250)\ny_coords = np.arange(start_y, end_y, 250)\nxv, yv = np.meshgrid(x_coords, y_coords)\ncombinations = np.vstack([xv.ravel(), yv.ravel()])\n\nGet chip geoemtry.\n\ngrid_cells = gpd.GeoSeries.from_xy(x=combinations[0], y=combinations[1], crs=signatures.crs).buffer(125, cap_style=3)\n\nFilter only those fully within signatures.\n\nsig_idx, grid_idx = grid_cells.sindex.query(signatures.geometry, predicate=\"contains\")\nvalid_grid_cells = grid_cells.iloc[grid_idx].to_frame('geometry')\nvalid_grid_cells[\"sig_id\"] = sig_idx\n\nGet unique signature IDs to pull from.\n\nunique = valid_grid_cells.sig_id.unique()\nunique.shape[0]\n\n745\n\n\nIllustrate the split using Hilbert distance. Chip groups with less than 20 chips are not split and should be allocated together either to train or test. The distance itself could be retrieved via GeoSeries.hilbert_distance() if needed.\n\ng = valid_grid_cells[valid_grid_cells.sig_id == unique[79]]\nif g.shape[0] &gt; 20:\n    split = np.empty(g.shape[0], dtype=int)\n    floor = int(np.floor(g.shape[0] * 0.8))\n    split[:floor] = 0\n    split[floor:] = 1\nelse:\n    split = np.ones(g.shape[0])\n\nf, ax = plt.subplots(1, 2, sharey=True)\ng.sort_values(\"geometry\").plot(split, ax=ax[0])\ng.sort_values(\"geometry\").plot(cmap=\"viridis\", ax=ax[1])\nax[0].set_title(\"split\")\nax[1].set_title(\"hilbert distance\")\n\nText(0.5, 1.0, 'hilbert distance')"
  },
  {
    "objectID": "notebooks/hello.html",
    "href": "notebooks/hello.html",
    "title": "Example notebook",
    "section": "",
    "text": "These should not be executed by Quarto.\n\nimport geopandas\n\ngeopandas.show_versions()\n\n\nSYSTEM INFO\n-----------\npython     : 3.11.4 | packaged by conda-forge | (main, Jun 10 2023, 18:08:41) [Clang 15.0.7 ]\nexecutable : /Users/martin/miniforge3/envs/stable/bin/python\nmachine    : macOS-14.5-arm64-arm-64bit\n\nGEOS, GDAL, PROJ INFO\n---------------------\nGEOS       : 3.12.1\nGEOS lib   : None\nGDAL       : 3.7.3\nGDAL data dir: /Users/martin/miniforge3/envs/stable/share/gdal\nPROJ       : 9.3.0\nPROJ data dir: /Users/martin/miniforge3/envs/stable/share/proj\n\nPYTHON DEPENDENCIES\n-------------------\ngeopandas  : 0.14.4\nnumpy      : 1.26.4\npandas     : 2.2.2\npyproj     : 3.6.1\nshapely    : 2.0.4\nfiona      : 1.9.5\ngeoalchemy2: None\ngeopy      : 2.4.1\nmatplotlib : 3.8.4\nmapclassify: 2.6.1\npygeos     : None\npyogrio    : 0.7.2\npsycopg2   : None\npyarrow    : 16.1.0\nrtree      : 1.2.0",
    "crumbs": [
      "Notebooks",
      "Example notebook"
    ]
  }
]